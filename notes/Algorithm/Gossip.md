
# 将前m个数放到末尾
---
## 法一 --- 三次逆序
- Reverse前m个
- Reverse后n-m个
- Reverse整体
- $\mathrm{O\left( \frac{m}{2} \right)+O\left( \frac{{n-m}}{2} \right)+O\left( \frac{n}{2} \right)=O(n)}$

## 法二 --- 双指针交换
- 如果能引入额外空间，可以先把前m个寄存在数组中，移动后n-m个，然后取回来
- 能否压掉额外空间呢？尝试把寄存和取出的过程改写为交换
- 将整个数组切分为m,m,m,...,r份，其中r是小于等于m的余数，那么可以以m个为一组，一组一组往后交换，最终会留下r个。这一过程实际上将m<n/2的情形转化为了m>n/2的情形
- 接下来将最后的m+r个作为一组，就等价于n=m+r的情形，即递归了n
- m>n/2的情形需要从后往前交换，方向相反了，需要写两个算法，而且不方便合并
- 能否把m<n/2的情形改写为从后往前交换呢？
- 在前面的思考中，我们总是维护后n-m个的相对顺序不被干扰。现在转换思路，我们直接把前m个拿到最后而不维护后n-m个的相对顺序。
- 将第m个与第n个交换，第m-1个与第n-1个交换，直到第1个与第n-m个交换
- 若m<n/2，则容易看出化归为了N=n-m的情形
- 若m>n/2，则需注意最后的n-m个数实际发生了多次交换，前m个数被完整地放在了最后，而后n-m个数有一部分被错误的换到了开头，应当有r=m%(n-m)个
- 综合两种情况，实际上都化归为N=n-m的情形，且目标序列均为r=m%(n-m)
- 总结上述过程，交换需要两个指针，一个在前一个在后，后者从n遍历至1，前者从m遍历至1然后计算新的m再次遍历，时间复杂度O(n)，循环退出条件m=0